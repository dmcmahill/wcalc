// FreeFEM microstrip analysis
//
// The starting point was an example from C Deibele on
// https://www.freelists.org/post/si-list/microstrip-and-stripline-FREEFEM-examples
// It appears that the syntax for FreeFEM must have changed so this file has been
// modified to work with FreeFEM-4.10 with some notation changed to be consistent
// with wcalc.
//
// Note that in microstrip a pure TEM mode is not possible so this analysis
// ignores dispersion

include "utils.edp"

// set to true to pause after each plot
bool debug = false;
//debug = true;

// used with the adaptive meshing
real errorinit = 0.001;
real error = errorinit;

// width of the microstrip
real W = 50;

// metal thickness
real Tmet = 0.7;

// dielectric thickness
real H = 62;

// this is a trick with free-fem...the conductor must lie 
// just a bit above the dielectric interface
real hd3 = H + 0.01;

// relative dielectric constant above the microstrip line
real eps1 = 1;

// relative dielectric constant of the substrate
real er = 4.8;

// meshing constant
int m = 200;
int mgndTB = m;
int mgndLR = 20;
bool useAdaptMesh = false;
//useAdaptMesh = true;

// total height of the problem (enclosure height)
real Htot = H*20/er;


// total width of the problem (enclosure width)
real Wtot = W + 2*10*H;

// define labels for our borders
int gnd=3, line=4, interface=5;

// *****************************
// Define the boundaries
// *****************************

// border defines a 2D border in parametric coordinates

// microstrip height dielectric discontinuity
border discon(t=0., Wtot) {x = Wtot-t; y = H; label=interface;}
 
// outer conductor
border ocbot(t=0,Wtot) {x = t; y = 0; label=gnd;}
border ocrt1(t=0,H)  {x=Wtot; y=t; label=gnd;}
border ocrt2(t=H,Htot)  {x=Wtot; y=t; label=gnd;}
border octop(t=0,Wtot) {x=Wtot-t;y=Htot; label=gnd;}
border oclt2(t=H,Htot)  {x=0;y=Htot+H-t; label=gnd;}
border oclt1(t=0,H)  {x=0;y=H-t; label=gnd;}

 
// center conductor
border cc(t=0, 2*W + 2*Tmet) {
    if ( t<=W ) {
        x = t + 0.5*Wtot - 0.5*W;  
        y = hd3;
    } else if ( ( t>W ) && ( t<=W  +Tmet ) ) {
        x = 0.5*(W + Wtot);      
        y = hd3 + t - W;
    } else if ( ( t>W + Tmet ) && ( t<=2*W + Tmet ) ) {
        x = 2*W + Tmet - t + 0.5*(Wtot - W);
        y = hd3 + Tmet;
    } else {
        x = 0.5*Wtot - 0.5*W;    
        y = 2*W + hd3 + 2*Tmet - t;
    }
    label=line;
}

// center conductor -- also clockwise
border ccB(t=0, 1) {
    x = 0.5*Wtot - 0.5*W + W*t;
    y = hd3;
    label = line;
}

border ccR(t=0, 1) {
    x = 0.5*Wtot + 0.5*W;
    y = hd3 + Tmet*t;
    label = line;
}

border ccT(t=0, 1) {
    x = 0.5*Wtot + 0.5*W - W*t;
    y = hd3 + Tmet;
    label = line;
}

border ccL(t=0, 1) {
    x = 0.5*Wtot - 0.5*W;
    y = hd3 + Tmet*(1 - t);
    label = line;
}

// *****************************
// Mesh generation
// *****************************

// Build's a 2D mesh using border elements
// 
mesh Th = buildmesh (ccL(-m) + ccR(-m) + ccT(-m) + ccB(-m) + ocbot(m) + ocrt1(m) + ocrt2(m) + octop(m) + oclt2(m) + oclt1(m) + discon(m*2));
plot(Th, cmm="Mesh", wait=debug);


// *****************************
// FE-space and FE-function
// *****************************
fespace Uh(Th, P1); // piecewise linear polynomials
fespace Ph(Th,P0);  // constant polynomials

// *****************************
// Mathematical Formula
// *****************************

// define the relative dielectric constant
func epsi = 1. + (eps1-1)*(y>H) + (er-1)*(y<H);

// *****************************
// Weak Formulation
// *****************************

// Solve when the dielectric is all free space
Uh u0;
Uh v0;

problem Laplace0(u0, v0)
    = int2d(Th) (grad(u0)' * grad(v0))
    + on(line, u0=1.)
    + on(gnd, u0=0.)
    ;

// Adaptmesh loop
if(useAdaptMesh) {
    error = errorinit;
    for (int j = 0; j < 4 ; j++){
        Laplace0;
        Th = adaptmesh(Th, u0, err=error);
        plot(Th, fill=false, cmm="adaptive mesh - free space", wait=debug);
        error = error/2;
    }
}
Laplace0;
plot(u0, cmm="Freespace Electric Potential", wait=debug);

// Solve with the dielectric in place
Uh u1;
Uh v1;

problem Laplace1(u1, v1)
    = int2d(Th) (epsi * grad(u1)' * grad(v1))
    + on(line, u1=1.)
    + on(gnd, u1=0.)
    ;

// Adaptmesh loop
if(useAdaptMesh) {
    error = errorinit;
    for (int j = 0; j < 4 ; j++){
        Laplace1;
        Th = adaptmesh(Th, u1, err=error);
        plot(Th, fill=false, cmm="adaptive mesh - with dielectric", wait=debug);
        error = error/2;
    }
}
Laplace1;
plot(u1, cmm="Electric Potential with Dielectric(s) in Place", wait=debug);

if(debug) {
    Ph Ex = dx(u1);   // Vx =du/dx is a P0 function
    Ph Ey = dy(u1);   // Vy =du/dy is a P0 function

    plot([Ex,Ey], cmm="Electric field vectors", wait=debug) ;

    // not sure what I'm doing wrong, charge should be proportional
    // to capacitance and also the ratio should scale with with
    // effective dielectric constant.  However, I get a ratio
    // that varies a lot with meshing.  Maybe it is simply an accuracy
    // issue?  Is the energy integration more accurate being a volume
    // measurement instead of just the boundary?
    real charge0 =  int1d(Th,line)( grad(u0)'*[N.x,N.y]) ;
    real charge1 =  int1d(Th,line)( epsi*grad(u1)'*[N.x,N.y]) ;
    cout << "charge0 = " <<  charge0 << endl;
    cout << "charge1 = " <<  charge1 << endl;
    cout << "charge1 / charge0 " << charge1/charge0 << endl;
}


// find total stored energy in the free space case
real energy0 = eps0 * int2d(Th) ( (dx(u0))*(dx(u0)) + (dy(u0))*(dy(u0)));

// find total stored energy in the case with the dielectric in place
real energy1 = eps0* int2d(Th) ( epsi*(dx(u1))*(dx(u1)) + epsi*(dy(u1))*(dy(u1)));
cout << "energy in free space   = " << energy0 << endl;
cout << "energy with dielectric = " << energy1 << endl;

// energy = 0.5*C*(V*V) and since we have applied a unit potential
// energy is proportional to capacitance and so the ratio of energies
// gives the effective relative dielectric constant
real keff = energy1/energy0;

// z0 = sqrt(L/C); velocity = 1/sqrt(LC)
// L = 1/(velocity*velocity*C)
// z0 = sqrt(1/(velocity*velocity*C*C)) = 1/(velocity*C)
// velocity = c0/sqrt(keff)
// energy = 0.5*C*V*V but V=1 so C = 2*energy
//
real z0 = sqrt(keff)/(c0 * energy1);
real z0no = 1/(c0 * energy0);

cout << "effective dielectric constant = " << keff << endl;
cout << "characteristic impedance = " << z0 << " Ohms" << endl;

cout << "Lightspeed  = " << c0 << " m/s" << endl;
cout << "mu0         = " << mu0 << " H/m" << endl;
cout << "eps0        = " << eps0 << " F/m" << endl;
cout << "freespaceZ0 = " << z0no << " Ohms" << endl;
cout << "W           = " << W << endl;
cout << "H           = " << H << endl;
cout << "Tmet        = " << Tmet << endl;
cout << "Wtot        = " << Wtot << endl;
cout << "er          = " << er << endl;

ofstream logf("microstrip.txt");
// Width, Height, Metal Thickness, Dielectric Constant, : , effective dielectric constant, z0
logf << W << " " << H << " " << Tmet << " " << er << " : " << keff << " " << z0 << endl;

